#+TITLE: CMake Cross-compile for Tiva Microcontrollers
* Introduction
This project lets you use ~cmake~ to compile programs for TI Tiva microcontrollers using either ~gcc~ or ~TI~ toolchains and
write them to flash memory using the in-circuit debugger on TI's LaunchPad development boards.
You can use ~tiva-cmake~ as a [[*Template Mode (No Installation)][template]] or you can [[*Installation][install]] it and use it as a dependency for your project.

When using ~tiva-cmake~ as a template you must manually install the [[*Development Tools][Development Tools]], whereas the dependencies are automatically installed
for Linux users during [[*Installation][installation]]. This project works without requiring [[https://www.ti.com/tool/CCSTUDIO][Code Composer Studio]];
however, installing it is one way to obtain the necessary development tools.

* Template Mode (No Installation)
Make sure you have the necessary [[*Dependencies]] installed. 

1. Clone this repository:
   - ~git clone https://github.com/m-elwin/tiva-cmake my_project_directory~
2. Create the build directory and compile the example code:
   #+BEGIN_SRC bash
   cd my_project_directory
   mkdir build
   cd build
   
   # Use one of the next two "cmake" lines to use either the ti-cgt compiler or gcc.
   # Add -DTIVA_MCU=TM4Cxxxx to specify the microcontroller: it defaults to the TM4C123GH6PM
   # cmake -DCMAKE_TOOLCHAIN_FILE=../cmake/ti-cgt-arm-toolchain.cmake ../src
   cmake -DCMAKE_TOOLCHAIN_FILE=../cmake/arm-none-eabi-gcc-toolchain.cmake ../src
   
   make
   
   # Write the binary to the microcontroller 
   # (assuming you have an EK-TM4C123GXL LaunchPad plugged in and turned on!)
   make led_example.write 
   #+END_SRC

When successful, you should see LED on the ~EK-TM4C123GXL~ cycle between red, white, and blue.
Continue by modifying and adding code in ~src/~. See [[*Startup Code][Startup Code]] for information
about how to implement interrupt service routines.

* Installation
** Ubuntu/Debian
1. Download and install the latest ~.deb~ package, which will also bring in the dependencies
   #+BEGIN_SRC bash
   curl -o tiva-cmake.deb [[https://github.url.comingsoon]]
   sudo apt install ./tiva-cmake
   #+END_SRC 
2. Optional: If you want to use TI's compiler in addition to ~gcc~, Install [[*Dependencies][Dependencies]] 

** Arch Linux
1. Download and install the latest ~package~, which will also bring in the dependencies
   #+BEGIN_SRC bash
   curl -o tiva-cmake.deb [[https://github.url.comingsoon]]
   sudo pacman -U tiva-cmake
   #+END_SRC 
2. Optional: install the ~arm-none-eabi-gdb~ to use a debugger. 
3. Optional: If you want to use TI's compiler in addition to ~gcc~, Install [[*Dependencies][Dependencies]]

** Windows
1. Install [[*Dependencies][Dependencies]] 
2. Download the latest [[windows_installer][windows installer]]

** macOS
1. Install [[*Dependencies][Dependencies]]
2. Download the latest mac installer [[windows_installer][windows installer]]

** All Platforms 
1. Install [[*Dependencies][Dependencies]] 
2. #+BEGIN_SRC bash
   git clone git@github.com:m-elwin/tiva-cmake
   mkdir tiva-cmake/build
   cd tiva-cmake/build
   cmake ..
   make 
   sudo make install
   #+END_SRC
   - By default, this method installs into the ~/usr/local~ prefix
   - Change the install prefix using ~-DCMAKE_INSTALL_PREFIX=/your/prefix/path~ when invoking ~cmake~
   - CMake Files are placed in ~$prefix/share/cmake/tiva-cmake~ 
   - Release and debug driverlib versions are installed to ~$prefix/lib/libdriverlib*~

* Usage 
** New Project (Using ~tiva-cmake~ as a template)
   - See [[*Template Mode (No Installation)][Template Mode]]: make a copy of ~tiva-cmake~ and add your code.
** New Project (Using an installed copy ~tiva-cmake~)
- Use ~cmake -E tiva-template > CMakeLists.txt~ to create your project's ~CMakeLists.txt~.
- Edit ~CMakeLists.txt~ to add your source code and specify your libraries and executables.
- Create a ~build~ directory and invoke ~cmake~ from it, specifying the desired toolchain:
  - For gcc: ~-DCMAKE_TOOLCHAIN_FILE=arm-none-eabi-gcc-toolchain.cmake~
  - For TI cgt: ~-DCMAKE_TOOLCHAIN_FILE=ti-cgt-arm-toolchain.cmake~
  - You can also specify the MCU using ~-DTIVA_MCU=~. Supported values are
    - ~TM4C124GH6PM~ (This is the default)
    - Others are coming soon (feel free to create an issue or pull request)!
** Flashing the Firmware
Every executable target you create (via ~add_executable(target_name ...)~ in ~cmake~ adds methods for flashing the firmware using the LaunchPad's In-Circuit Debugger.
1. ~make target_name.write~ Flash the program onto the microcontroller using one of the methods below, which are listed in order of preference
   1. ~make target_name.ocd~ Flash the program using ~openocd~ 
   2. ~make target_name.uni~ Flash the program using ~UniFlash~ 
   3. ~make target_name.lm4~ Flash the program using ~lm4tools~
** Debugging with GDB
- You need ~arm-none-eabi-gdb~ or ~gdb-multiarch~ and ~openocd~ (see [[*Development Tools][Development Tools]]).
- For best results build your code with ~CMAKE_BUILD_TYPE=Debug~ (see [[*Build Types][Build Types]])
- ~make target_name.attach~ will attach to an already running debug session with gdb
- ~make target_name.gdb~ will flash the firmware using openocd and load the program into the debugger

* CMake Settings
Most ~cmake~ settings can be modifed using the ~cmake-gui~ (where the toolchain can also be selected). 

** Changing the Microcontroller
- Passing ~-DTIVA_MCU=<model>~ when invoking ~cmake~ will change the targeted microcontroller from the default (~TM4C123GH6PM~).

** Compiler Selection
- There are two separate toolchains files: ~ti-cgt-arm-toolchain.cmake~ for TI's compiler and ~arm-none-eabi-gcc-toolchain.cmake~ which are used
  to switch between ~ti-cgt~ and ~gcc~. This section covers the behavior when you have multiple ~ti-cgt~ or ~arm-none-eabi-gcc~ versions installed.
- Compilers installed to standard system directories take precedence over those bundled with Code Composer Studio
- Later versions of compilers take precedence over older versions
- You can specify a specific compiler using ~-DCMAKE_C_COMPILER=/path/to/compiler~ and ~CMAKE_CXX_COMPILER=/path/to/compiler~ when invoking ~cmake~.

** Build Types
- CMake defaults to ~CMAKE_BUILD_TYPE=""~ which does not set any compiler flags (other than those necessary for cross compiling)
  - This mode is useful if you want complete control over flags
- For convenience, The template ~CMakeLists.txt~ file defaults the build type to ~Debug~.
  - Debug-level optimizations ~-Og~ are turned on for ~gcc~, as the [[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html][gcc manual]] recommends this debug level.  
  - The blank (~""~) build type does not specify an optimization level.
  
** TivaWare Driverlib
TI has released TivaWare ~driverlib~ under a BSD license and this project redistributes it under that license in the ~driverlib~ directory.
By default, ~tiva-cmake~ uses it's own bundled version of ~driverlib~.

When you compile with ~-DCMAKE_BUILD_TYPE=Debug~, you link to a debug version of ~driverlib~ that enables you to
step throught the ~driverlib~ code.  When you compile with ~-DCMAKE_BUILD_TYPE=Release~ you link with an optimized version of ~driverlib~.

Some options to override this default behavior:
1. Use ~-DDRIVERLIB_LIBRARIES=/path/to/library/driverlib.lib~ to point to a specific compiled version of the library
2. Use ~-DRIVERLIB_BUILD_TYPE=~ to select a build type for ~driverlib~ that differs from the project build type

* Microcontroller Support
The code has only been tested with the ~EK-TM4C123GXL~ LaunchPad. Therefore some options are specific to the ~TM4C123GH6PM~ microcontroller.

** Required Changes
To support another microcontrollers a few additions are needed
- Compiler options are set in ~/cmake/<mcu>-<compiler>-options.cmake~, where ~<compiler>~ is ~gcc~ or ~ti-cgt~ and ~<mcu>~ is the ~mcu~ model.
  - Compiler options for most Tiva microcontroller models should be similar. Good defaults can be obtained from Code Composer studio
    either by viewing the compile options in a project or reading the provided [[*Automatic Generation of Startup Code][targetDB files]].
- Startup code is stored in ~/startup/<mcu>-<compiler>-startup.c~
  - The interrupt vector table (see [[*Startup Code][Startup Code]]) likely requires adjustment.
- Linker scripts for ~gcc~ are stored in ~/startup/<mcu>-gcc.lds~ (~gcc~) and ~/startup/<mcu>-ti-cgt.cmd~ (~ti-cgt~)
  - Memory locations likely differ between microcontroller models.

- The startup code and linker scripts incorpoarted via ~target_link_libraries(<my_target> ${STARTUP_LIBRARIES})~. You can
  omit this line to use your own startup code or linker scripts in your own projects.

** Automatic Generation of Startup Code
- Future work will use TI's targetDB files, which provide information about MCU's including peripheral layout and compiler flags to automatically generate
  startup files. The generated startup files will then be included in this repository, to avoid a hard dependency on Code Composer Studio
- The targetDB ffiles and are distributed with Code Composer Studio and located in the ~ccs/ccs_base/common/targetdb~ directory.
  - ~targetdb/devices~ contains the ~<mcu>.xml~ files, which seem to be the main file for each chip.

* Startup Code
The startup code is set to be linked automatically by the example ~CMakeLists.txt~.  If you have installed ~tiva-cmake~ you need not directly
include these files in your source code.  However, it may be beneficial to include or even modify them; they are located in ~tiva-cmake/startup~
and installed to ~$prefix/usr/share/tiva-cmake/startup~.

The startup code is different than the code provided by TI and is designed to make development easier. 
1. To define an interrupt, simply declare a function with the name of that interrupt 
   - The naming scheme can be derived from the Exception and Interrupt tables in the datasheet
     - Remove all terms in parentheses
     - Replace the greek letter $\mu$ with a ~u~
     - Replace all non-alpha-numeric characters with an underscore
     - Prepend ISR_
   - For example 
     - "Non-Maskable Interrupt (NMI)" becomes ~ISR_Non_Maskable_Interrupt~
     - "16/32-Bit Timer 0A" becomes ~ISR_16_32_Bit_Timer_0A~
     - It ain't pretty, and may violate your style guide, but the transformations always result in valid C identifiers.
2. By default, all interrupts are mapped to a function called ~DefaultInterrupt~ that does nothing
   - You can override ~DefaultInterrupt~ by declaring it in your own code. It is handy for debugging to do something
     in this handler to indicate that it has been triggered since, for example, the default FaultISR calls ~DefaultInterrupt~
   - Note that ~Reserved~ interrupts are set to Null (0).

* Prerequisites
Installing [[https://www.ti.com/tool/CCSTUDIO][Code Composer Studio]] provides everything needed to build and flash your program.
However, Code Composer Studio is a large program and it may be desirable to obtain your tools elsewhere.

** GNU GCC Toolchain
To use ~gcc~ you need the ~arm-none-eabi~ toolchain with the ~newlib~ C library and optionally (for debugging)
either ~multiarch gdb~ or ~arm-none-eabi-gdb~. Code composer studio comes bundled with ~gcc~, but it is usally an older version.
*** Ubuntu
The necessary files can be installed from ~apt~ (including ~gdb~).
~sudo apt install  gcc-arm-none-eabi libnewlib-arm-none-eabi gdb-multiarch~
*** Arch Linux
The necessary files can be installed via ~pacman~ (including ~gdb~).
~sudo pacman -S arm-none-eabi-gcc arm-none-eabi-newlib arm-none-eabi-gdb~

*** Other
If the toolchain is unavailable in your package manager it can be [[https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads][downloaded directly from arm]]
- On Linux, move the tarball you downloaded either to ~/opt~ or to ~/home/$(whoami)~ and upack it with ~tar xf~.
- Installers are also provided for Windows and macOS.

** TI Tools (Without Code Composer Studio)
You can install TI's compiler and flash tool indepedently of Code Composer Studio 
1. [[http://www.ti.com/tool/ARM-CGT][ARM-CGT (TI's arm compiler)]]
   On Linux, install either to ~/opt~ or ~/home/$(whoami)~, keeping the default subdirectory name ~ti-cgt-arm_...etc...~.
2. [[http://www.ti.com/tool/UNIFLASH][UNIFLASH]]
   Install to either ~/opt~ or ~/home/$whoami~
   - ~openocd~ is better supported than the independently installed uniflash tool.
** Third-Party Flash Tools
You can install ~openocd~ or ~lm4tools~.  Instructions are provided for ~openocd~ since it has been more reliable than ~lm4tools~ in my experience.
** Ubuntu
~sudo apt install openocd~
** Archlinux
~pacman -S openocd~
** Other
Download from http://openocd.org/ and install to the standard location or ~/home/$(whoami)/openocd~

* Note
I have not tested all possible combinations of installation/locations, but the behavior described in this document constitutes a loose specification.
If you think you have the proper tools installed to a permissible location, or think this package should allow installation to a different location, please file an issue.



