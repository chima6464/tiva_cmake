#+TITLE: CMake Cross-compile for Tiva Microcontrollers
* Introduction
A CMake toolchain focused on Texas Instruments (TI) Tiva-C microcontrollers (although likely modifiable to other arm processors).  
It enables the use of ~arm-none-eabi-gcc~ or TI's Code Generation Tools (~ti-cgt~) and provides a method to write your
code to flash memory using the in-circuit debugger (ICD) on TI's LaunchPad development boards. 
For convenience, it also comes bundled with ~TivaWare~ ~driverlib~.

You can use ~tiva-cmake~ as a [[*Template Mode (No Installation)][template]] or [[*Installation][install]] it (either to your home directory or system-wide) and use it as a dependency. 

When using ~tiva-cmake~ as a [[*Template Mode (No Installation)][template]] you must manually install the [[*Development Tools][Development Tools]] ([[https://www.ti.com/tool/CCSTUDIO][Code Composer Studio]] is sufficient but not necessary).
Some [[*Installation][installation]] methods automatically install the required development tools.

* Template Mode (No Installation)
The example assumes that you have an ~EK-TM4C123GXL~ plugged into a USB port and the [[*Development Tools][Development Tools]] installed.

1. Clone this repository:
   - ~git clone https://github.com/m-elwin/tiva-cmake my_project_directory~
2. Create the build directory, compile, and flash:
   #+BEGIN_SRC bash
   cd my_project_directory
   mkdir build
   cd build
   cmake ..
   make
   make led_example.write 
   #+END_SRC

When successful, you should see LED on the ~EK-TM4C123GXL~ cycle between red, white, and blue.

The project source code resides in ~src/~, which is the sole location you should need to edit.
- ~src/PreLoad.cmake~ sets the default toolchain: you can modify this file or override using
    ~-DCMAKE_TOOLCHAIN_FILE=arm-none-eabi-gcc-toolchain.cmake~ for ~gcc~
    ~-DCMAKE_TOOLCHAIN_FILE=ti-cgt-arm-toolchain.cmake~ for ~ti-cgt~
- See [[*Startup Library][Startup Library]] for information about how to implement interrupt service routines.
- To change the microcontroller model add ~-DCMAKE_SYSTEM_PROCESSOR=TM4Cxxxxx~ or set it in ~src/PreLoad.cmake~
- See [[*CMake Settings][CMake Settings]] for details and other options.   


* Installation
** Ubuntu/Debian
1. Download and install the latest ~.deb~ package, which will also bring in the dependencies
   #+BEGIN_SRC bash
   curl -o tiva-cmake.deb [[https://github.url.comingsoon]]
   sudo apt install ./tiva-cmake
   #+END_SRC 
2. Optional: If you want to use TI's compiler in addition to ~gcc~, Install [[*Dependencies][Dependencies]] 

** Arch Linux
1. Download and install the latest ~package~, which will also bring in the dependencies
   #+BEGIN_SRC bash
   curl -o tiva-cmake.deb [[https://github.url.comingsoon]]
   sudo pacman -U tiva-cmake
   #+END_SRC 
2. Optional: install the ~arm-none-eabi-gdb~ to use a debugger. 
3. Optional: If you want to use TI's compiler in addition to ~gcc~, Install [[*Dependencies][Dependencies]]

** Windows
1. Install [[*Dependencies][Dependencies]] 
2. Download the latest [[windows_installer][windows installer]]

** macOS
1. Install [[*Dependencies][Dependencies]]
2. Download the latest mac installer [[windows_installer][windows installer]]

** All Platforms 
1. Install [[*Dependencies][Dependencies]] 
2. #+BEGIN_SRC bash
   git clone git@github.com:m-elwin/tiva-cmake
   mkdir tiva-cmake/build
   cd tiva-cmake/build
   cmake ..
   make 
   sudo make install
   #+END_SRC
   - By default, this method installs into the ~/usr/local~ prefix
   - Change the install prefix using ~-DCMAKE_INSTALL_PREFIX=/your/prefix/path~ when invoking ~cmake~
   - CMake Files are placed in ~$prefix/share/cmake/tiva-cmake~ 
   - Release and debug driverlib versions are installed to ~$prefix/lib/libdriverlib*~



* Usage 
** New Project (Using an installed copy ~tiva-cmake~)
- Use ~cmake -P tiva-template > CMakeLists.txt~ to create your project's ~CMakeLists.txt~
- Edit ~CMakeLists.txt~ to add your source code and specify your libraries and executables.
- Use ~cmake~ as usual, except specify ~-DCMAKE_TOOLCHAIN_FILE=tiva-cmake-toolchain.cmake~ when
  configuring the project for the first time.
- See [[*CMake Settings][CMake Settings]] for other options

** Flashing the Firmware
Every executable target you create (via ~add_executable(target_name ...)~ in ~cmake~ adds methods for flashing the firmware using the LaunchPad's In-Circuit Debugger.
1. ~make target_name.write~ Flash the program onto the microcontroller using one of the methods below, which are listed in order of preference
   1. ~make target_name.ocd~ Flash the program using ~openocd~ 
   2. ~make target_name.uni~ Flash the program using ~UniFlash~ 
   3. ~make target_name.lm4~ Flash the program using ~lm4tools~
** Debugging with GDB
- You need ~arm-none-eabi-gdb~ or ~gdb-multiarch~ and ~openocd~ (see [[*Development Tools][Development Tools]]).
- For best results build your code with ~CMAKE_BUILD_TYPE=Debug~ (see [[*Build Types][Build Types]])
- ~make target_name.attach~ will attach to an already running debug session with gdb
- ~make target_name.gdb~ will flash the firmware using openocd and load the program into the debugger

* CMake Settings
Most ~cmake~ settings can be modifed using the ~cmake-gui~ (where the toolchain can also be selected when first configuring the project). 

** Selecting the toolchain
- The default toolchain file is ~tiva-toolchain.cmake~ 
  - It selects ~gcc~ if it is installed, otherwise it uses ~ti-cgt~
- The toolchain file for ~gcc~ is ~tiva-gcc-toolchain.cmake~ 
- The toolchain file for ~ti-cgt~ is ~tiva-ti-toolchain.cmake~

*** Compiler Selection
Here are some rules for how the compiler is selected when there are multiple versions involved.
1. The toolchain file selects the compiler family, as outlined above
2. Find compilers installed in your home directory: if found select the latest version
3. Find compilers installed to system directories such as ~/opt~ or ~/usr/bin~: if found select the latest version
4. Find compilers installed by Code Composer Studio: if found select the latest version

You can specify a specific compiler using ~-DCMAKE_C_COMPILER=/path/to/compiler~ and ~CMAKE_CXX_COMPILER=/path/to/compiler~ when invoking ~cmake~.
If the compiler you specify is compatible with ~gcc~ you should use ~tiva-gcc-toolchain.cmake~ and if it is compatible with ~ti-cgt~ use
~tiva-ti-toolchain.cmake~.


** Changing the Microcontroller
- Passing ~-DCMAKE_SYSTEM_PROCESSOR=<model>~ when invoking ~cmake~ will change the targeted microcontroller from the default (~TM4C123GH6PM~).

** Microcontroller Support
The code has only been tested with the ~EK-TM4C123GXL~ LaunchPad. Therefore some options are specific to the ~TM4C123GH6PM~ microcontroller
and must be modified for other microcontrollers (issues/pull requests welcome)
- The ~TM4C123_REVISION~ and ~TM4C129_REVISION~ are used to set the silicon revision when using TivaWare. See ~tivaware/TivaWareConfig.cmake~ for details.
*** Required Changes
To support another microcontrollers a few additions are needed
- Compiler options that are dependent on microcontroller model are set in ~/cmake/Platform/arm-none-eabi-<compiler>-<model>.cmake~, 
  where ~<compiler>~ is ~gcc~ or ~ti-cgt~ and ~<model>~ is the microcontroller model. These files are automatically loaded by CMake.
  - Good defaults for compiler options can be obtained from Code Composer studio
    either by viewing the compile options in a project or reading the provided [[*Automatic Generation of Startup Library][targetDB files]].
- Startup code is stored in ~/startup/<model>-<compiler>-startup.c~
  - The interrupt vector table (see [[*Startup Library][Startup Library]]) likely requires adjustment.
- Linker scripts for ~gcc~ are stored in ~/startup/<model>-gcc.lds~ (~gcc~) and ~/startup/<mcu>-ti-cgt.cmd~ (~ti-cgt~)
  - Memory locations likely differ between microcontroller models and so the linker scripts should be adjusted.

- The startup code and linker scripts incorpoarted via ~target_link_libraries(<my_target> ${STARTUP_LIBRARIES})~. You can
  omit this line to use your own startup code or linker scripts in your own projects.
*** Automatic Generation of Startup Library
- Future work will use TI's targetDB files, which provide information about MCU's including peripheral layout and compiler flags to automatically generate
  startup files. The generated startup files will then be included in this repository, to avoid a hard dependency on Code Composer Studio
- The targetDB ffiles and are distributed with Code Composer Studio and located in the ~ccs/ccs_base/common/targetdb~ directory.
  - ~targetdb/devices~ contains the ~<model>.xml~ files, which seem to be the main file for each chip.


** Build Types
- CMake defaults to ~CMAKE_BUILD_TYPE=""~ which does not set any compiler flags (other than those necessary for cross compiling)
  - This mode is useful if you want complete control over flags
- For convenience, The template ~CMakeLists.txt~ file defaults the build type to ~Debug~.
  - Debug-level optimizations ~-Og~ are turned on for ~gcc~, as the [[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html][gcc manual]] recommends this debug level.  
  - The blank (~""~) build type does not specify an optimization level.
  
** TivaWare Driverlib
TI has released TivaWare ~driverlib~ under a BSD license and this project redistributes it under that license in the ~driverlib~ directory.
By default, ~tiva-cmake~ uses it's own bundled version of ~driverlib~.

When you compile with ~-DCMAKE_BUILD_TYPE=Debug~, you link to a debug version of ~driverlib~ that enables you to
step throught the ~driverlib~ code.  When you compile with ~-DCMAKE_BUILD_TYPE=Release~ you link with an optimized version of ~driverlib~.

Some options to override this default behavior:
1. Use ~-DDRIVERLIB_LIBRARIES=/path/to/library/driverlib.lib~ to point to a specific compiled version of the library
2. Use ~-DRIVERLIB_BUILD_TYPE=~ to select a build type for ~driverlib~ that differs from the project build type

* Startup Library
The startup library contains code that runs before ~main()~ to initialize the microcontroller,
the linker scripts, and the interrupt vector table.  This code differs between microcontroller models
and is stored in ~lib/<model>~.  

The startup code is different than the code provided by TI and is designed to make development easier. 
1. To define an interrupt in your code, simply declare a function with the name of that interrupt, no need to modify the startup library
   - The naming scheme can be derived from the Exception and Interrupt tables in the TI Datasheet
     - Remove all terms in parentheses
     - Replace the greek letter $\mu$ with a ~u~
     - Replace all non-alpha-numeric characters with an underscore
     - Prepend ISR_
   - For example 
     - "Non-Maskable Interrupt (NMI)" becomes ~ISR_Non_Maskable_Interrupt~
     - "16/32-Bit Timer 0A" becomes ~ISR_16_32_Bit_Timer_0A~
     - It ain't pretty, and may violate your style guide, but the transformations always result in valid C identifiers.
2. By default, all ISRs call ~ISR_Default~, a function that does nothing. By providing your own definition for ~ISR_Default~ you
   can modify that this default behavior.  Even if you don't enable interrupts, fault ISRs can still be triggered.
   - ~Reserved~ interrupts are set to ~NULL~ (0).

It may be beneficial to modify the startup code directly in your project, in which case simply omit ~TivaCMake::startup~ from the target link libraries.
You can make basic changes to the stack and heap sizes using options for the compiler, but such changes may also require editing the linker scripts.

* Development Tools
Installing [[https://www.ti.com/tool/CCSTUDIO][Code Composer Studio]] provides everything needed to build and flash your program.
However, Code Composer Studio is a large program and it may be desirable to obtain your tools elsewhere.

** GNU GCC Toolchain
To use ~gcc~ you need the ~arm-none-eabi~ toolchain with the ~newlib~ C library and optionally (for debugging)
either ~multiarch gdb~ or ~arm-none-eabi-gdb~. Code composer studio comes bundled with ~gcc~, but it is usally an older version.
*** Ubuntu
The necessary files can be installed from ~apt~ (including ~gdb~).
~sudo apt install  gcc-arm-none-eabi libnewlib-arm-none-eabi gdb-multiarch~
*** Arch Linux
The necessary files can be installed via ~pacman~ (including ~gdb~).
~sudo pacman -S arm-none-eabi-gcc arm-none-eabi-newlib arm-none-eabi-gdb~

*** Other
If the toolchain is unavailable in your package manager it can be [[https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads][downloaded directly from arm]]
- On Linux, move the tarball you downloaded either to ~/opt~ or to ~/home/$(whoami)~ and upack it with ~tar xf~.
- Installers are also provided for Windows and macOS.

** TI Tools (Without Code Composer Studio)
You can install TI's compiler and flash tool indepedently of Code Composer Studio 
1. [[http://www.ti.com/tool/ARM-CGT][ARM-CGT (TI's arm compiler)]]
   On Linux, install either to ~/opt~ or ~/home/$(whoami)~, keeping the default subdirectory name ~ti-cgt-arm_...etc...~.
2. [[http://www.ti.com/tool/UNIFLASH][UNIFLASH]]
   Install to either ~/opt~ or ~/home/$whoami~
   - ~openocd~ is better supported than the independently installed uniflash tool.
** Third-Party Flash Tools
You can install ~openocd~ or ~lm4tools~.  Instructions are provided for ~openocd~ since it has been more reliable than ~lm4tools~ in my experience.
** Ubuntu
~sudo apt install openocd~
** Archlinux
~pacman -S openocd~
** Other
Download from http://openocd.org/ and install to the standard location or ~/home/$(whoami)/openocd~

* Note
I have not tested all possible combinations of installation/locations, but the behavior described in this document constitutes a loose specification.
If you think you have the proper tools installed to a permissible location, or think this package should allow installation to a different location, please file an issue.



